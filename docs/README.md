# 실시간 시스템 리소스 모니터링 - PRD

## 1. 개요

### 1.1 목적
서버의 실시간 시스템 리소스를 수집, 모니터링하고 이상 상태를 감지하여 안정적인 서비스 운영을 지원하는 모니터링 시스템 구축

### 1.2 목표
- 실시간 시스템 메트릭 수집 및 시각화
- 리소스 임계값 초과 시 자동 알림
- 히스토리 데이터 저장 및 트렌드 분석
- 프로세스별 상세 모니터링

### 1.3 범위
**In Scope:**
- CPU, 메모리, 디스크, 네트워크 메트릭 수집
- 실시간 모니터링 대시보드
- 알림 시스템 (이메일, Slack 등)
- 메트릭 데이터 저장 및 조회 API

**Out of Scope:**
- 애플리케이션 레벨 모니터링 (APM)
- 분산 트레이싱
- 로그 집계

---

## 2. 기능 요구사항

### 2.1 메트릭 수집

#### 2.1.1 CPU 메트릭
- **전체 CPU 사용률** (%)
  - user, system, idle, iowait 별도 수집
  - 코어별 사용률
- **CPU 로드 평균** (1분, 5분, 15분)
- **수집 주기**: 5초
- **데이터 보존 기간**:
  - Raw 데이터: 24시간
  - 1분 평균: 7일
  - 1시간 평균: 30일

#### 2.1.2 메모리 메트릭
- **물리 메모리**
  - 전체 메모리
  - 사용 중인 메모리
  - 사용 가능한 메모리
  - 캐시/버퍼 메모리
  - 사용률 (%)
- **스왑 메모리**
  - 전체 스왑
  - 사용 중인 스왑
  - 사용률 (%)
- **수집 주기**: 5초
- **데이터 보존 기간**: 2.1.1과 동일

#### 2.1.3 디스크 메트릭
- **디스크 사용량**
  - 마운트 포인트별 전체/사용/가용 용량
  - 사용률 (%)
  - inode 사용률
- **디스크 I/O**
  - 읽기/쓰기 속도 (MB/s)
  - IOPS (초당 I/O 작업 수)
  - I/O 대기 시간
- **수집 주기**:
  - 사용량: 30초
  - I/O: 5초
- **데이터 보존 기간**: 2.1.1과 동일

#### 2.1.4 네트워크 메트릭
- **네트워크 인터페이스별**
  - 수신/송신 바이트 (bytes/s)
  - 수신/송신 패킷 (packets/s)
  - 에러 및 드롭된 패킷 수
  - 대역폭 사용률 (%)
- **연결 상태**
  - ESTABLISHED, TIME_WAIT, CLOSE_WAIT 등 상태별 연결 수
- **수집 주기**: 5초
- **데이터 보존 기간**: 2.1.1과 동일

#### 2.1.5 프로세스 메트릭
- **Top N 프로세스** (CPU/메모리 사용량 기준)
  - 프로세스 ID (PID)
  - 프로세스 이름
  - CPU 사용률
  - 메모리 사용량 (RSS, VSZ)
  - 실행 사용자
  - 실행 시간
- **수집 주기**: 10초
- **저장 개수**: Top 20 프로세스

### 2.2 실시간 대시보드

#### 2.2.1 메인 대시보드
- 전체 시스템 상태 한눈에 파악
- 주요 메트릭 실시간 차트 (최근 1시간)
  - CPU 사용률 (라인 차트)
  - 메모리 사용률 (라인 차트 + 현재 값)
  - 디스크 사용률 (바 차트)
  - 네트워크 트래픽 (Area 차트)
- 현재 상태 표시 (정상/경고/위험)
- 자동 새로고침 (5초 간격)

#### 2.2.2 상세 대시보드
- **CPU 상세**
  - 코어별 사용률
  - 로드 평균 트렌드
  - Top CPU 프로세스
- **메모리 상세**
  - 메모리 유형별 사용량 (스택 차트)
  - 스왑 사용 히스토리
  - Top 메모리 프로세스
- **디스크 상세**
  - 파티션별 사용률
  - I/O 성능 그래프
  - 디스크별 IOPS
- **네트워크 상세**
  - 인터페이스별 트래픽
  - 연결 상태 분포
  - 패킷 에러율

#### 2.2.3 시간 범위 선택
- 최근 1시간 (기본값)
- 최근 6시간
- 최근 24시간
- 최근 7일
- 커스텀 범위 (시작/종료 시간 선택)

### 2.3 알림 시스템

#### 2.3.1 알림 조건 설정
- **임계값 기반 알림**
  - CPU 사용률 > 80% (경고), > 90% (위험)
  - 메모리 사용률 > 85% (경고), > 95% (위험)
  - 디스크 사용률 > 80% (경고), > 90% (위험)
  - 네트워크 에러율 > 1% (경고)
- **지속 시간 조건**
  - 임계값 초과 상태가 N분 이상 지속될 때만 알림
  - 기본값: 5분
- **알림 빈도 제한**
  - 동일 조건에 대해 최소 간격 설정 (기본 30분)

#### 2.3.2 알림 채널
- **이메일**
  - 수신자 목록 설정
  - HTML 형식 메시지
  - 메트릭 차트 첨부
- **Slack**
  - Webhook URL 설정
  - 채널별 알림 전송
  - 인터랙티브 버튼 (상세보기, 확인)
- **Webhook**
  - 커스텀 엔드포인트로 JSON 전송
  - 외부 시스템 연동

#### 2.3.3 알림 이력
- 발생 시간
- 알림 종류 및 심각도
- 메트릭 값
- 해결 시간
- 알림 상태 (발생/진행중/해결)

### 2.4 API

#### 2.4.1 메트릭 조회 API
```
GET /api/metrics/{metric_type}
Query Parameters:
  - start: 시작 시간 (ISO 8601)
  - end: 종료 시간 (ISO 8601)
  - interval: 집계 간격 (5s, 1m, 5m, 1h)
  - host: 호스트 필터 (옵션)

Response:
{
  "metric_type": "cpu",
  "interval": "1m",
  "data": [
    {
      "timestamp": "2026-02-02T10:00:00Z",
      "value": 45.2,
      "host": "server-01"
    }
  ]
}
```

#### 2.4.2 현재 상태 조회 API
```
GET /api/status
Response:
{
  "host": "server-01",
  "timestamp": "2026-02-02T10:05:30Z",
  "cpu": {
    "usage_percent": 45.2,
    "load_avg": [2.1, 1.8, 1.5]
  },
  "memory": {
    "usage_percent": 62.3,
    "used_gb": 15.8,
    "total_gb": 32.0
  },
  "disk": [
    {
      "mount": "/",
      "usage_percent": 45.0,
      "used_gb": 90.0,
      "total_gb": 200.0
    }
  ],
  "network": {
    "eth0": {
      "rx_bytes_per_sec": 1048576,
      "tx_bytes_per_sec": 524288
    }
  }
}
```

#### 2.4.3 알림 설정 API
```
POST /api/alerts/rules
Body:
{
  "name": "High CPU Alert",
  "metric": "cpu_usage",
  "condition": "gt",
  "threshold": 80,
  "duration": "5m",
  "severity": "warning",
  "channels": ["email", "slack"]
}

GET /api/alerts/history
DELETE /api/alerts/rules/{rule_id}
```

---

## 3. 기술 요구사항

### 3.1 수집 에이전트
- **언어**: Python 3.9+ 또는 Go
- **라이브러리**:
  - Python: psutil, prometheus_client
  - Go: gopsutil, prometheus client
- **배포 방식**: systemd service 또는 Docker container
- **리소스 제약**:
  - CPU 사용률 < 2%
  - 메모리 사용량 < 50MB

### 3.2 데이터 저장
- **시계열 DB**: Prometheus 또는 InfluxDB
- **메타데이터**: PostgreSQL 또는 MySQL
- **데이터 압축**: 자동 다운샘플링
- **보존 정책**:
  - 고해상도 데이터: 24시간
  - 중간 해상도: 7일
  - 저해상도: 30일

### 3.3 백엔드
- **언어**: Python (FastAPI) 또는 Node.js (Express)
- **인증**: JWT 또는 API Key
- **Rate Limiting**: 사용자당 1000 req/hour
- **캐싱**: Redis (5분 TTL)

### 3.4 프론트엔드
- **프레임워크**: React 또는 Vue.js
- **차트 라이브러리**: Chart.js, Recharts, 또는 Apache ECharts
- **반응형 디자인**: 모바일 지원
- **웹소켓**: 실시간 데이터 스트리밍

### 3.5 인프라
- **컨테이너화**: Docker
- **오케스트레이션**: Docker Compose 또는 Kubernetes
- **모니터링**: 자체 모니터링 (메타 모니터링)
- **로깅**: 구조화된 로그 (JSON 형식)

---

## 4. 비기능 요구사항

### 4.1 성능
- 메트릭 수집 지연 < 1초
- API 응답 시간 < 500ms (95 percentile)
- 대시보드 로딩 시간 < 3초
- 동시 접속 지원: 100명 이상

### 4.2 확장성
- 수평 확장 가능한 아키텍처
- 100대 이상의 서버 모니터링 지원
- 메트릭 수집 에이전트 자동 등록

### 4.3 가용성
- 서비스 가용성 99.5% 이상
- 자동 장애 복구
- Health check 엔드포인트

### 4.4 보안
- HTTPS 통신 (TLS 1.2 이상)
- 인증/인가 구현
- 민감 정보 암호화 (DB 패스워드, API 키)
- 감사 로그

### 4.5 유지보수성
- 코드 커버리지 80% 이상
- 자동화된 테스트 (Unit, Integration)
- CI/CD 파이프라인
- 문서화 (API, 배포, 운영)

---

## 5. 사용자 스토리

### 5.1 시스템 관리자
1. 서버 상태를 실시간으로 확인하고 싶다
2. CPU 사용률이 높을 때 자동으로 알림을 받고 싶다
3. 과거 특정 시점의 메트릭을 확인하고 싶다
4. 여러 서버를 한 화면에서 비교하고 싶다

### 5.2 개발자
1. API를 통해 메트릭 데이터를 가져와 분석하고 싶다
2. 특정 배포 전후의 리소스 변화를 확인하고 싶다
3. 커스텀 알림 조건을 설정하고 싶다

### 5.3 경영진
1. 서버 인프라 현황을 요약된 리포트로 받고 싶다
2. 리소스 사용 트렌드를 통해 용량 계획을 수립하고 싶다

---

## 6. UI/UX 요구사항

### 6.1 디자인 원칙
- 직관적인 인터페이스
- 다크 모드 지원
- 색상 코딩 (정상: 녹색, 경고: 노란색, 위험: 빨간색)

### 6.2 주요 화면
1. **대시보드** - 전체 시스템 상태 개요
2. **메트릭 상세** - 특정 메트릭 드릴다운
3. **알림 관리** - 알림 규칙 설정 및 이력
4. **서버 목록** - 모니터링 대상 서버 관리
5. **설정** - 사용자 설정 및 알림 채널 설정

---

## 7. 일정

### Phase 1: MVP (4주)
- Week 1-2: 메트릭 수집 에이전트 개발
- Week 3: 데이터 저장 및 API 개발
- Week 4: 기본 대시보드 개발

### Phase 2: 기능 확장 (4주)
- Week 5: 알림 시스템 구현
- Week 6: 상세 대시보드 개발
- Week 7: 프로세스 모니터링 추가
- Week 8: 테스트 및 최적화

### Phase 3: 운영화 (2주)
- Week 9: 문서화 및 배포 자동화
- Week 10: 프로덕션 배포 및 모니터링

---

## 8. 성공 지표

- 시스템 장애 감지 시간 < 5분
- 오탐율 (False Positive) < 5%
- 사용자 만족도 > 4.0/5.0
- 시스템 가동 시간 > 99.5%
- 알림 응답 시간 < 1분

---

## 9. 위험 요소 및 대응

| 위험 | 영향도 | 확률 | 대응 방안 |
|------|--------|------|-----------|
| 대량 메트릭으로 인한 DB 부하 | 높음 | 중간 | 다운샘플링 및 보존 정책 적용 |
| 에이전트 장애 시 메트릭 유실 | 중간 | 낮음 | 로컬 버퍼링 및 재시도 로직 |
| 네트워크 지연으로 인한 수집 지연 | 중간 | 중간 | 타임아웃 설정 및 비동기 처리 |
| 알림 폭주 (Alert Storm) | 높음 | 중간 | 알림 그룹핑 및 빈도 제한 |

---

## 10. 향후 계획

- 머신러닝 기반 이상 감지
- 예측 분석 (미래 리소스 사용량 예측)
- 멀티 테넌시 지원
- Kubernetes 네이티브 모니터링
- 모바일 앱 개발
